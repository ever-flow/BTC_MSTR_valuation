# -*- coding: utf-8 -*-
# Colab/노트북: 한글 폰트 및 경고 최소화
!pip -q install koreanize_matplotlib

import warnings, math
warnings.filterwarnings("ignore")

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt

from sklearn.metrics import r2_score, mean_squared_error
from sklearn.linear_model import HuberRegressor
from datetime import timedelta
import koreanize_matplotlib 


"""
MSTR ↔ BTC ECM 강화 모델 v2.3.1 (Lookahead Bias Corrected, Plot/Print Fix)
- v2.3 대비 개선:
  1) 한글 글리프 경고 제거(스타일 이후 폰트 재지정), 라벨/범례 한글 고정
  2) f-string 출력 버그 수정(날짜/윈도우 표시)
  3) 동적 임계밴드 계산의 수치적 안정성 강화(ddof, 최소표본 체크)
  4) 코드 정리: 함수 단위/주석 보강 (모델 로직은 동일)
"""

# =========================
# 설정값
# =========================
START = "2021-01-01"
AUTO_ADJUST = True   # yfinance 최신 기본 True이지만 명시적 지정 유지
ROLLING_WIN = 180    # 동적 파라미터 및 롤링 통계 계산용 윈도우
THRESHOLD_Z = 1.5    # 동적 임계값 Z-score (1.5: 약 86% 신뢰구간)
SCENARIO_LEVELS = [30_000, 75_000, 100_000, 120_000, 150_000, 200_000, 300_000]
SEED = 42
np.random.seed(SEED)
pd.options.display.float_format = lambda x: f"{x:,.2f}"

# =========================
# 유틸 · 데이터
# =========================
def prep_data(df: pd.DataFrame, col_name: str) -> pd.DataFrame:
    """야후 파이낸스 데이터프레임을 날짜·종가로 정리"""
    out = pd.DataFrame({"date": df.index, col_name: df["Close"].squeeze()})
    out["date"] = pd.to_datetime(out["date"]).dt.tz_localize(None).dt.normalize()
    out = out.drop_duplicates(subset="date", keep="last")
    out[col_name] = pd.to_numeric(out[col_name], errors="coerce")
    return out

def load_and_merge_data(start_date=START, auto_adjust=AUTO_ADJUST) -> pd.DataFrame:
    """BTC와 MSTR 데이터를 로드/병합하고 로그변환 컬럼 추가"""
    btc = yf.download("BTC-USD", start=start_date, auto_adjust=auto_adjust, progress=False)
    mst = yf.download("MSTR", start=start_date, auto_adjust=auto_adjust, progress=False)

    btc_df = prep_data(btc, "BTC")
    mst_df = prep_data(mst, "MSTR")

    df = pd.merge(btc_df, mst_df, on="date", how="inner").sort_values("date").dropna()
    df = df[(df["BTC"] > 0) & (df["MSTR"] > 0)].copy()

    if len(df) < ROLLING_WIN:
        raise SystemExit(f"⚠️ 표본({len(df)}개)이 롤링 윈도우({ROLLING_WIN}일)보다 적습니다.")

    df["lnx"] = np.log(df["BTC"])
    df["lny"] = np.log(df["MSTR"])
    return df

def get_live_price(ticker: str, fallback_price: float, auto_adjust=AUTO_ADJUST):
    """실시간 가격을 안전하게 가져오고, 실패 시 대체값 사용"""
    try:
        hist = yf.Ticker(ticker).history(period="1d", interval="1m", auto_adjust=auto_adjust)
        if not hist.empty and pd.notna(hist["Close"].iloc[-1]):
            return float(hist["Close"].iloc[-1]), "live(1m)"
    except Exception:
        pass

    try:
        hist_daily = yf.download(ticker, period="5d", interval="1d",
                                 auto_adjust=auto_adjust, progress=False)
        if not hist_daily.empty and pd.notna(hist_daily["Close"].iloc[-1]):
            return float(hist_daily["Close"].iloc[-1]), "daily_close"
    except Exception:
        pass

    return float(fallback_price), "fallback_df"

# =========================
# ECM 모델 함수
# =========================
def longrun_robust_fit(lnx: np.ndarray, lny: np.ndarray):
    """HuberRegressor로 이상치에 강건한 장기 관계 추정: ln(MSTR)=ln_a + b*ln(BTC)"""
    X = lnx.reshape(-1, 1)
    huber = HuberRegressor().fit(X, lny)
    return float(huber.intercept_), float(huber.coef_[0])

def ecm_fit(lnx_tr: np.ndarray, lny_tr: np.ndarray):
    """전체 기간 데이터에 대한 ECM 적합 및 성능 평가"""
    # 1) 장기(공적분 관계)
    ln_a, b = longrun_robust_fit(lnx_tr, lny_tr)
    resid = lny_tr - (ln_a + b * lnx_tr)
    lny_fit_long = ln_a + b * lnx_tr

    # 2) 단기(오차수정항 포함)
    dly = np.diff(lny_tr); dlx = np.diff(lnx_tr); s_lag = resid[:-1]
    Z = np.vstack([s_lag, dlx]).T
    phi, beta = np.linalg.lstsq(Z, dly, rcond=None)[0]

    # 3) 성능지표
    performance = {
        "long_R2": r2_score(lny_tr, lny_fit_long),
        "long_RMSE": np.sqrt(mean_squared_error(lny_tr, lny_fit_long)),
        "short_R2": r2_score(dly, phi * s_lag + beta * dlx)
    }
    return {
        "longrun": {"ln_a": float(ln_a), "b": float(b)},
        "shortrun": {"phi": float(phi), "beta": float(beta)},
        "residuals": resid,
        "performance": performance
    }

# =========================
# 1) 데이터 준비
# =========================
df = load_and_merge_data()
lnx_full, lny_full = df["lnx"].to_numpy(float), df["lny"].to_numpy(float)

btc_now, btc_src = get_live_price("BTC-USD", df["BTC"].iloc[-1])
mstr_now, mstr_src = get_live_price("MSTR", df["MSTR"].iloc[-1])

# =========================
# 2) 정적(Static) 모델 학습
# =========================
params_full_static = ecm_fit(lnx_full, lny_full)
ln_a_static = params_full_static["longrun"]["ln_a"]
b_static     = params_full_static["longrun"]["b"]
performance_metrics = params_full_static["performance"]

# =========================
# 3) 최근(동적) 파라미터
# =========================
ln_a_dynamic, b_dynamic = longrun_robust_fit(lnx_full[-ROLLING_WIN:], lny_full[-ROLLING_WIN:])

# =========================
# 4) 현재 FV/프리미엄
# =========================
mstr_fv_static  = float(np.exp(ln_a_static  + b_static  * np.log(btc_now)))
prem_static     = (mstr_now / mstr_fv_static) - 1.0

mstr_fv_dynamic = float(np.exp(ln_a_dynamic + b_dynamic * np.log(btc_now)))
prem_dynamic    = (mstr_now / mstr_fv_dynamic) - 1.0

# =========================
# 5) [룩어헤드 제거] 동적 임계값(프리미엄) 계산
#    과거 시점별 롤링 파라미터로 FV를 계산해 프리미엄 시계열 생성
# =========================
rolling_params = [
    longrun_robust_fit(lnx_full[i-ROLLING_WIN:i], lny_full[i-ROLLING_WIN:i])
    for i in range(ROLLING_WIN, len(lnx_full))
]
rolling_ln_a, rolling_b = (np.array([p[0] for p in rolling_params]),
                           np.array([p[1] for p in rolling_params]))

# FV_t = exp(ln_a_t + b_t * ln(BTC_t))
fv_series_dynamic = np.exp(rolling_ln_a + rolling_b * lnx_full[ROLLING_WIN:])
mstr_series_eval  = df["MSTR"].to_numpy()[ROLLING_WIN:]

premium_series_dynamic = (mstr_series_eval / fv_series_dynamic) - 1.0  # vectorized

# 임계값은 "최근 ROLLING_WIN 구간"만으로 산출(최신 국면 반영)
# 표본 부족/표준편차 0 보호
tail = premium_series_dynamic[-ROLLING_WIN:]
if len(tail) < 3:
    tail = premium_series_dynamic  # 안전장치
prem_roll_mean = float(np.mean(tail))
prem_roll_std  = float(np.std(tail, ddof=1)) if len(tail) > 2 else float(np.std(tail))

# 분산이 과도하게 낮으면(=σ≈0) 최소 폭을 부여해 신호 경직 방지
EPS = 1e-6
eff_std = max(prem_roll_std, EPS)

buy_threshold  = prem_roll_mean - (THRESHOLD_Z * eff_std)
sell_threshold = prem_roll_mean + (THRESHOLD_Z * eff_std)

def get_current_zone(premium: float, buy_thresh: float, sell_thresh: float) -> str:
    if premium <= buy_thresh:
        return f"매수 고려 Zone (≤ {buy_thresh:.2%})"
    if premium >= sell_thresh:
        return f"매도 고려 Zone (≥ {sell_threshold:.2%})"
    return f"중립 Zone ({buy_thresh:.2%} ~ {sell_thresh:.2%})"

current_zone = get_current_zone(prem_dynamic, buy_threshold, sell_threshold)

# =========================
# 리포트 출력
# =========================
print("===== 현재 시점 MSTR 가치평가 요약 =====")
print(f"BTC 현재가: ${btc_now:,.2f} ({btc_src}) | MSTR 현재가: ${mstr_now:,.2f} ({mstr_src})")

summary_df = pd.DataFrame({
    "구분": ["공정가치 (FV)", "프리미엄", "현재 상태"],
    "정적 모델 (Static)":  [f"${mstr_fv_static:,.2f} (b={b_static:.3f})",
                           f"{prem_static:.2%}", "-"],
    "동적 모델 (Dynamic)": [f"${mstr_fv_dynamic:,.2f} (b={b_dynamic:.3f})",
                           f"{prem_dynamic:.2%}", current_zone]
})
display(summary_df)

print(f"\n[해석] 동적 모델 기준, 현재 MSTR 프리미엄({prem_dynamic:.2%})은(는) '{current_zone}'에 위치합니다.")
print(f"* 동적 임계값: Z-score={THRESHOLD_Z}, Rolling Window={ROLLING_WIN}일 기준")
print(f"* 정적 모델: 전체 기간({df['date'].min().date()} ~ {df['date'].max().date()})의 평균 관계. 구조적 위치 파악용.")
print(f"* 동적 모델: 최근 {ROLLING_WIN}일의 시장 관계. 현재 시점의 매매 판단용.")

# --- 시나리오 분석 ---
print("\n===== BTC 가격 시나리오별 MSTR 공정가치 추정 =====")
scenario_data = []
for btc_target in SCENARIO_LEVELS:
    ln_btc_target = math.log(btc_target)
    mstr_pred_static  = float(np.exp(ln_a_static  + b_static  * ln_btc_target))
    mstr_pred_dynamic = float(np.exp(ln_a_dynamic + b_dynamic * ln_btc_target))
    scenario_data.append({
        "BTC 시나리오 가격": f"${btc_target:,.0f}",
        "MSTR 예상가 (정적 모델)":  f"${mstr_pred_static:,.2f}",
        "MSTR 예상가 (동적 모델)":  f"${mstr_pred_dynamic:,.2f}",
    })
scenario_df = pd.DataFrame(scenario_data)
display(scenario_df)
print("* 위 추정치는 현재 모델의 파라미터(b)가 미래에도 유지된다는 가정 하의 이론적 가격입니다.")

# --- 모델 성능 ---
print("\n===== 전체 기간(Static) 모델 성능 지표 =====")
perf_df = pd.DataFrame({
    "모델 구분": ["장기 관계 (ln(MSTR) ~ ln(BTC))", "단기 동학 (Δln(MSTR) ~ error, Δln(BTC))"],
    "설명력 (R²)": [f"{performance_metrics['long_R2']:.3f}", f"{performance_metrics['short_R2']:.3f}"],
    "로그 오차 (RMSE)": [f"{performance_metrics['long_RMSE']:.4f}", "-"]
})
display(perf_df)
print("* R²(설명력): 1에 가까울수록 모델이 데이터를 잘 설명함.")
print("* RMSE(로그 오차): 0에 가까울수록 모델의 예측 오차가 적음.")

# =========================
# 시각화
# =========================
# 스타일을 켠 뒤, 폰트가 바뀌지 않도록 다시 폰트 고정
plt.style.use('seaborn-v0_8-whitegrid')
try:
    import koreanize_matplotlib  # 재호출로 폰트 재고정
    plt.rcParams["font.family"] = "Malgun Gothic"
    plt.rcParams["axes.unicode_minus"] = False
except Exception:
    pass

fig, axes = plt.subplots(3, 1, figsize=(12, 18))
fig.suptitle('MSTR-BTC ECM 분석 시각화 (v2.3.1)', fontsize=18, y=0.95)

# 1) 산점도 + 정적 장기선
a_static = float(np.exp(ln_a_static))
x_grid = np.linspace(df["BTC"].min(), df["BTC"].max(), 400)
y_fit  = a_static * np.power(x_grid, b_static)

axes[0].scatter(df["BTC"], df["MSTR"], s=12, alpha=0.6, label="관측치")
axes[0].plot(x_grid, y_fit, linewidth=2.0, label=f"장기 강건회귀선 (전체 기간)\ny={a_static:.2e}·x^{b_static:.4f}")
axes[0].set_xscale("log"); axes[0].set_yscale("log")
axes[0].set_xlabel("BTC (USD, 로그 스케일)"); axes[0].set_ylabel("MSTR (USD, 로그 스케일)")
axes[0].set_title("MSTR vs BTC (산점도 및 장기 공정선)")
axes[0].legend(loc="best")

# 2) 롤링 베타(b_t) 추이
dates = pd.to_datetime(df["date"]).to_numpy()
ts = dates[ROLLING_WIN:]
axes[1].plot(ts, rolling_b, linewidth=1.5, label=f"롤링 {ROLLING_WIN}일 b_t")
axes[1].axhline(b_static, linewidth=1.2, linestyle='--', alpha=0.7, label=f"전체(정적) b={b_static:.3f}")
axes[1].axhline(b_dynamic, linewidth=1.2, linestyle='--', alpha=0.7, label=f"최근(동적) b={b_dynamic:.3f}")
axes[1].set_title(f"롤링 {ROLLING_WIN}일 탄력도(b) 변화 추이")
axes[1].legend(loc="best")

# 3) 동적 프리미엄(%) + 동적 임계 밴드
premium_df = pd.DataFrame({
    "date": df["date"].iloc[ROLLING_WIN:],
    "premium": premium_series_dynamic * 100.0  # % 단위
}).reset_index(drop=True)

# 롤링 평균/표준편차 계산(동일 윈도우, ddof=1) + 수치적 안전장치
roll_mean = premium_df["premium"].rolling(window=ROLLING_WIN, min_periods=max(3, ROLLING_WIN//5)).mean()
roll_std  = premium_df["premium"].rolling(window=ROLLING_WIN, min_periods=max(3, ROLLING_WIN//5)).std(ddof=1)
roll_std  = roll_std.fillna(method="bfill").fillna(roll_std.mean()).clip(lower=1e-6)

premium_df["roll_mean"] = roll_mean
premium_df["upper_band"] = roll_mean + (THRESHOLD_Z * roll_std)
premium_df["lower_band"] = roll_mean - (THRESHOLD_Z * roll_std)

axes[2].plot(premium_df["date"], premium_df["premium"], linewidth=1.5, alpha=0.8, label="동적 프리미엄(%)")
axes[2].plot(premium_df["date"], premium_df["upper_band"], linestyle='--', linewidth=1.0, label=f"매도 고려 Zone (Mean + {THRESHOLD_Z}σ)")
axes[2].plot(premium_df["date"], premium_df["lower_band"], linestyle='--', linewidth=1.0, label=f"매수 고려 Zone (Mean - {THRESHOLD_Z}σ)")
axes[2].axhline(0, linewidth=1, alpha=0.6)

# 현재 프리미엄 포인트 시각적 강조(미래로 약간 이동해 점을 띄움)
axes[2].scatter(premium_df["date"].iloc[-1] + timedelta(days=5),
                prem_dynamic * 100.0, s=50, zorder=5,
                label=f"현재 프리미엄 ({prem_dynamic:.2%})")

axes[2].set_title("동적 프리미엄(%) 시계열과 동적 매매 고려 Zone")
axes[2].set_xlabel("날짜"); axes[2].set_ylabel("Premium (%)")
axes[2].legend(loc="best")

plt.tight_layout(rect=[0, 0, 1, 0.95])
plt.show()
